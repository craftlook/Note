# MySQL-MVCC 详解

## MVCC介绍

全称 Multi-Version Concurrency Control  多版本控制，主要目的为提高数据库的并发性能(InnoDB引擎下)。对同一行的数据发生并发读写时，为了避免数据冲突，可以通过上锁阻塞实现。MVCC则不用增加锁，用更好的方式处理了读-写请求的并发问题。（此处的读是快照读，读分为快照读、当前读）

## 快照读与当前读

### 当前读

读的数据库中的记录都是当前最新的版本，会对当前读取记录进行加锁，防止其他事务修改数据。(悲观锁)

如下操作都是当前读：

* select ... lock in shard mode（共享锁）
* select ... for update（排他锁）
* update（排他锁）
* insert（排他锁）
* delete（排他锁）
* serializable 串行化事务隔离级别

### 快照读

读的实现基于MVCC，快照读读取的数据不一定是当前最新的版本，有可能是历史版本

如下操作都是快照读

* 不加锁的select （隔离级别不是serializable）

**快照读与MVCC的关系：** MVCC是维持一个数据多个版本，使读写操作没有冲突的一个概念，具体实现是快照读。

## MVCC解决并发

### 数据库并发场景

* 读 - 读：不存在问题，不需要并发控制
* 读 - 写：线程安全问题，造成事务隔离性问题，如：脏读、幻读、不可重复读
* 写 - 写：线程安全问题，存在更新丢失问题，如：第一类更新丢失、第二类更新丢失 [详情](#F-S-INFO)

### 解决哪些问题

MVCC用来解决**读 - 写**冲突的无锁的并发控制，为事务分配递增的时间戳（事务id）。为每个数据修改保存一个版本，版本与事务时间戳相关联。读操作只读取该**事务开始前**对应的**数据库快照**。可以做到读操作不用阻塞写操作，同时写操作不会阻塞读操作。解决了**脏读**、**幻读**、**不可重复读**等事务隔离性的问题，但是未解决 **写 - 写 更新丢失问题** 。（[如何解决写 - 写更新丢失](#F-S-SOLVE)）

## MVCC实现原理

MVCC实现通过**版本链**、**undo日志**、**ReadView**来实现的

### 版本链

数据库隐藏字段：**事务ID**、**回滚指针**、**自增ID**、**删除标示**

* db_trx_id：6 byte，最近更新（修改、插入）事务ID，记录最后一次修改、插入数据行的事务ID；
* db_roll_pointer: 7 byte, 回滚指针指向该记录的上一个版本（存储在rollback segment里）；
* dd_row_id: 6 byte，隐藏自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id生产一个聚簇索引；
* 删除flag：隐藏字段, 记录被更新或删除并不代表真的删除，而是**删除flag**变了。

数据行（示例）：

| name | age  | db_row_id(隐式主键) | db_trx_id(事务ID) | db_roll_pointer(回滚指针) |
| ---- | ---- | ------------------- | ----------------- | ------------------------- |
| will | 32   | 1                   | 1                 | 0x12445444                |

如上表，db_row_id是数据库默认为该记录生成的唯一隐式索引，db_trx_id记录了当前操作的事务ID，而 db_roll_pointer回滚指针，通过undo日志，指向上一个旧版本。

每次对数据库记录进行改动，都会记录undo日志，每个undo日志都有一个db_roll_pointer属性（insert操作对应的undo日志中没有该属性，因为该记录没有更早的版本）。可以通过undo日志中的db_roll_pointer串联日志，形成一个链表。如图：

![avatar](https://github.com/craftlook/Note/blob/master/image/db_roll_pointer%E6%97%A5%E5%BF%97%E9%93%BE.png)

对记录进行每次更新后，都会将旧值放入到undo日志中，随着多次更新，所有的版本都通会被db_roll_pointer属性连接形成一条链表，称之为<font color="red">**版本链**</font>，版本链的头部是该记录的最新值。每个版本中都包含该版本对应的事务ID，在根据ReadView判断版本时会用到。

### undo日志（[MySQL事务日志简介](#mysql-log)）

undo log主要用于记录被修改前的日志，在表信息修改前先会把数据拷贝到undo log里。当**数据回滚**时通过undo log中的数据进行数据还原。

#### 用途

* 保证事务进行回滚时的原子性和一致性，当事务进行回滚的时候通过undo log 事务对应的数据进行恢复；
* 用于MVCC的快照读数据，在多版本控制时，通过undo log 的历史数据可以实现**不同事务版本号**都拥有自己的**独立快照数据版本**。

#### 种类

* insert undo log : 代表事务在insert时产生的undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃；
* update undo log：事务在update或delete时产生的undo log，不仅事务回滚需要，快照读时也需要。不可随便删除，只有在快照读或者事务回滚不涉及该日志时，对应的日志才可以被purge线程统一清除。

### Read View(读视图)

事务进行快照读操作时产生**读视图**(read view)，在该事务执行的快照读时，会生成数据库系统当前的一个快照。

记录并维护系统当前**活跃的事务ID**（没有提交，当每个事务开启时，都会分配一个事务ID，这个ID是递增的），即系统不该被当前读事务看到的其他事务ID列表。

Read View主要用来做**可见性**的判断，即当某个事务执行快照读的时候，对该记录创建一个Read View视图，把它作为条件用来判断**当前事务可以看到哪个版本的数据**，可以是最新数据也可以是undo log中的版本数据。

#### 属性

* trx_ids: 当前系统活跃（未提交）版本号集合；
* low_limit_id: 创建当前 Read View时，最大事务版本号+1；
* up_limit_id: 创建当前Read View时，系统活页事务最小版本号；
* creator_trx_id: 创建当前Read View的事务版本号。

#### 可见性判断（源码）

![avatar](https://github.com/craftlook/Note/blob/master/image/read-view-code.png)

* `db_trx_id` < `up_limit_id` || `db_trx_id` == `creator_trx_id`（显示）
  * 如果数据事务ID小于read view中的**最小活跃事务ID**，则可以肯定该数据是在当前事务启之前就已经存在了的,所以可以显示。
  * 或者数据的`事务ID`等于`creator_trx_id` ，那么说明这个数据就是当前事务`自己生成的`，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以`显示`的。

* `db_trx_id` >= `low_limit_id`（不显示）
  * 如果数据事务ID大于read view 中的当前系统的`最大事务ID`，则说明该数据是在当前read view 创建`之后才产生`的，所以数据`不显示`。如果小于则进入下一个判断
* `db_trx_id`是否在`活跃事务`（trx_ids）中
  * `不存在`：则说明read view产生的时候事务`已经commit`了，这种情况数据则可以`显示`。
  * `已存在`：则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的。

## MVCC与隔离级别

根据上面的介绍，Read View支持 RC （读提交）和 RR （可重复读）的隔离级别实现。

### RC与RR快照生成时机

* RC：每个快照读都会生成并获取最新的Read View；
* RR：同一个事务中的第一个快照才会创建Read View，之后事务中的快照读获取都是同一个Read View，之后查询就不会重复生成，所以一个事务的查询结果每次都是一样的。

### 解决幻读

* 快照读：通过MVCC控制，不用加锁。按照MVCC中规定的语法进行增删改查操作，以避免幻读。
* 当前读：通过next-key锁（行锁+gap锁）来解决问题。

### RC与RR下的快照读区别

* 在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；
* 即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见；
* RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因

## 总结

从以上的描述中我们可以看出来，所谓的MVCC指的就是在使用RC、RR这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。







## 补充内容

## <span id="F-S-INFO">第一类更新与第二类更新丢失 </span>

### 第一类

| 时间 | 事务A                                 | 事务B                |
| ---- | ------------------------------------- | -------------------- |
| t1   | **开始事务**                          |                      |
| t2   |                                       | **开始事务**         |
| t3   | 查询账户余额为1000元                  |                      |
| t4   |                                       | 查询账户余额为1000元 |
| t5   |                                       | 把余额改为1100元     |
| t6   |                                       | **提交事务**         |
| t7   | 把余额改为900元                       |                      |
| t8   | **回滚事务**                          |                      |
| t9   | **余额恢复为1000** **元（丢失更新）** |                      |

### 第二类

| 时间 | 事务A                | 事务B                               |
| ---- | -------------------- | ----------------------------------- |
| t1   | **开始事务**         |                                     |
| t2   |                      | **开始事务**                        |
| t3   | 查询账户余额为1000元 |                                     |
| t4   |                      | 查询账户余额为1000元                |
| t5   | 把余额改为900元      |                                     |
| t6   | ** 提交事务**        |                                     |
| t7   |                      | 把余额改为1100元                    |
| t8   |                      | **提交事务**                        |
| t9   |                      | **余额改为1000** **元（丢失更新）** |

## <span id="F-S-SOLVE">第一类更新与第二类更新丢失如何解决 </span>

基本两种思路，一种是**悲观锁**，另外一种是**乐观锁**

#### 悲观锁

在修改commit之前增加查询，此查询使用select ... for update 加锁。判断修改字段，如果字段未变化直接更新，如果字段变化返回通知用户。

#### 乐观锁

表增加版本号字段，用来记录数据的版本，每次更新时对版本号进行维护，查询出的版本作为查询条件进行更新。
