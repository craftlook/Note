# MySQL- 更新语句执行过程

[toc]

## Mysql 语句更新过程

执行SQL语句

```sql
update t set b = 100 where id = 1
```

<img src="https://github.com/craftlook/Note/blob/master/image/db/mysql-update.png" width="100%" heigth="100%"/>

**语句的执行过程如下**：

1. 客户端（通常是你的服务）发出更新语句” update t set b = 100 where id = 1“ 并向MySQL服务端建立连接；

2. MySQL连接器负责和客户端建立连接，获取权限，维持和管理连接；

3. **查询缓存**：MySQL拿到一个查询请求后，会先到查询缓存看看（MySQL8.x已经废弃了查询缓存）看之前是否已经执行过，如果执行过，执行语句及结果会以key-value形式存储到内存中；

   * 如果命中缓存会返回结果；
   * 如果没命中缓存，就开始真正执行语句；

   **分析器**：MySQL已经知道语句是要做什么。分析器会先做词法分析，识别出关键字update，表名等等；之后还会做语法分析，判断输入的语句是否符合MySQL语法；

4. **优化器**：选择使用哪个索引（如果多个表，会选择表的连接顺序）；

5. **执行器**：MySQL服务端最后一个阶段。执行器会调用引擎的接口去执行语句；

6. 事务开始（任何一个操作都是事务）：写undo log ，记录记录上一个版本数据（方便回滚），并更新记录的回滚指针和事务ID；

7. **执行器**先调用引擎取id=1这一行。id是主键，引擎直接用树搜索找到这一行；

   * 如果id=1这一行所在的数据页本来就在内存中（buffer pool缓存池），就直接返回给执行器更新；

   * 如果记录不在内存，接下来会判断索引是否是唯一索引；

     * 如果不是唯一索引，InnoDB会将更新操作缓存在change buffer中；

     * 如果是唯一索引，就只能将数据页从磁盘读入到内存，返回给执行；

8. **执行器**拿到引擎给的行数据，把这个值加上1（比如原来是N，现在就是N+1）得到新的一行数据，再调用引擎接口写入这行新数据；**引擎将这行数据更新到内存（buffer pool缓存池）**；

9. 更新操作记录到redo log 里面：写入 redo log buffer（内存缓冲区，用来存放redo log），将redo log记录先写入buffer中（如果断电的话就会丢失）；

10. redo log 刷入磁盘记录到redo日志文件中。redo log处于**prepare阶段**（两阶段提交）。 然后告知执行器执行完成了， 随时可以提交事务；

11. 执行器提交事物 ；

12. 执行器生成这个操作的binlog，并把binlog写入磁盘；

    * binlog写入磁盘中，发送binlog消息；
    * 12.1 如果是半同步，等待半同步ack响应；

13. 事务的两阶段提交：commit的commit阶段；

14. binlog commit 后：

    * **消除事物ID活跃列表(下次查询可见)**
    * 释放锁
    * **刷新redolog**
    * **消除MVCC快照信息**

15. binlog文件名称和位置和commit 标记写入redo log中。写入commit的作用：作为一个标识保证redolog和binlog的位置是一样的。引擎把刚刚写入的redo log改成提交（commit） 状态

16. 更新完成；

