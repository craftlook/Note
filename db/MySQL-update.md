* [MySQL- 更新语句执行过程](#mysql--更新语句执行过程)
  * [1. Mysql 语句更新过程](#1-mysql-语句更新过程)
  * [2. 执行过程中的相关知识点介绍](#2-执行过程中的相关知识点介绍)
    * [2.1 MySQL 基本结构](#21-mysql-基本结构)
      * [2.1.1 sql解析器](#211-sql解析器)
      * [2.1.2 查询优化器](#212-查询优化器)
      * [2.1.3 执行器](#213-执行器)
      * [2.1.4 存储引擎及结构](#214-存储引擎及结构)
        * [2.1.4.1 查询缓冲池](#2141-查询缓冲池)
        * [2.1.4.2 修改缓冲(change buffer)](#2142-修改缓冲change-buffer)
        * [2.1.4.3 undo日志(引擎层)](#2143-undo日志引擎层)
        * [2.1.4.4 redo日志(引擎层)](#2144-redo日志引擎层)
        * [2.1.4.5 Write-Ahead Logging机制(WAL预写日志)](#2145-write-ahead-logging机制wal预写日志)
        * [2.1.4.6 binlog日志(服务层)](#2146-binlog日志服务层)
        * [2.1.4.7 两阶段提交2PC](#2147-两阶段提交2pc)


# MySQL- 更新语句执行过程

[toc]

## 1. Mysql 语句更新过程

执行SQL语句

```sql
update t set b = 100 where id = 1
```

<img src="https://github.com/craftlook/Note/blob/master/image/db/mysql-update.png" width="100%" heigth="100%"/>

**语句的执行过程如下**：

1. 客户端（通常是你的服务）发出更新语句” update t set b = 100 where id = 1“ 并向MySQL服务端建立连接；

2. MySQL连接器负责和客户端建立连接，获取权限，维持和管理连接；

3. **查询缓存**：MySQL拿到一个查询请求后，会先到查询缓存看看（MySQL8.x已经废弃了查询缓存）看之前是否已经执行过，如果执行过，执行语句及结果会以key-value形式存储到内存中；

   * 如果命中缓存会返回结果；
   * 如果没命中缓存，就开始真正执行语句；
   
   **分析器**：MySQL已经知道语句是要做什么。分析器会先做词法分析，识别出关键字update，表名等等；之后还会做语法分析，判断输入的语句是否符合MySQL语法；
   
4. **优化器**：选择使用哪个索引（如果多个表，会选择表的连接顺序）；

5. **执行器**：MySQL服务端最后一个阶段。执行器会调用引擎的接口去执行语句；

6. 事务开始（任何一个操作都是事务）：写undo log ，记录记录上一个版本数据（方便回滚），并更新记录的回滚指针和事务ID；

7. **执行器**先调用引擎取id=1这一行。id是主键，引擎直接用树搜索找到这一行；

   * 如果id=1这一行所在的数据页本来就在内存中（buffer pool缓存池），就直接返回给执行器更新；

   * 如果记录不在内存，接下来会判断索引是否是唯一索引；

     * 如果不是唯一索引，InnoDB会将更新操作缓存在change buffer中；

     * 如果是唯一索引，就只能将数据页从磁盘读入到内存，返回给执行；

8. **执行器**拿到引擎给的行数据，把这个值加上1（比如原来是N，现在就是N+1）得到新的一行数据，再调用引擎接口写入这行新数据；**引擎将这行数据更新到内存（buffer pool缓存池）**；

9. 更新操作记录到redo log 里面：写入 redo log buffer（内存缓冲区，用来存放redo log），将redo log记录先写入buffer中（如果断电的话就会丢失）；

10. redo log 刷入磁盘记录到redo日志文件中。redo log处于**prepare阶段**（两阶段提交）。 然后告知执行器执行完成了， 随时可以提交事务；

11. 执行器提交事物 ；

12. 执行器生成这个操作的binlog，并把binlog写入磁盘；

    * binlog写入磁盘中，发送binlog消息；
    * 12.1 如果是半同步，等待半同步ack响应；

13. 事务的两阶段提交：commit的commit阶段；

14. binlog commit 后：

    * **消除事物ID活跃列表(下次查询可见)**
    * 释放锁
    * **刷新redolog**
    * **消除MVCC快照信息**

15. binlog文件名称和位置和commit 标记写入redo log中。写入commit的作用：作为一个标识保证redolog和binlog的位置是一样的。引擎把刚刚写入的redo log改成提交（commit） 状态

16. 更新完成；

## 2. 执行过程中的相关知识点介绍

### 2.1 MySQL 基本结构

mysql的内部组件：

* **sql解析器**：解析sql语言，负责分析语法，对于sql语句进行拆解等相关操作。

* **查询优化器**：查询优化器负责解析之后的sql语法进行逻辑的优化，保证sql可以按照最短路径来执行

* **存储引擎**：存储引擎是用于真正执行sql的组件，存储引擎按照sql语句进行内存和硬盘上的数据更新操作。同时使用对外的接口进行操作。

* **执行器**：执行器就是负责真正调用存储引擎上接口的组件。

#### 2.1.1 sql解析器

当我们通过tomcat发送一条请求的时候，数据库连接会干啥，他会根据tomcat发来的查询语句，通过一个叫做**sql解析器**的东西进行解析，**其实数据库服务器本身也不知道这条语句干啥用的**，所以sql解释器负责管理这个东西，在通过sql接口接受到请求之后，会传递个sql解析器去进行解析动作。

#### 2.1.2 查询优化器

优化器就是对于查询的路径进行优化和选择，比如下面的sql语句有两种选择（当然数据库真实执行肯定不是这样的，但是我们可以模糊的理解）

- 查询id=?的记录，并且提取对应的字段
- 查询优化器就是用来优化查询逻辑的，会用**最短的查询路径对于查询进行优化**。

#### 2.1.3 执行器

存储引擎可以执行sql语句，但是谁来操作存储引擎的接口呢？**实际上调用存储引擎接口的是执行器**，执行器会按照存储引擎的接口按照一定的逻辑对sql进行执行。那么要如何调用接口呢？执行器会根据当前的存储引擎配套一份**执行计划**，然后调用存储引擎完成sql的语句对于数据进行增删改查。

#### 2.1.4 存储引擎及结构

查询优化器还不是执行查询的地方，那么我们接下来再来看下查询优化器处理完之后如何处理。
我们都知道数据库无非是由一种特殊的数据结构构造的文件罢了，只是对外提供特定的接口以及需要按照mysql的语法才能对数据进行crud，既然是操作数据，那肯定逃不过硬盘和内存，既然存储引擎是直接和这个数据结构打交道的，那么通过查询优化器优化过的的查询语句肯定是要交给存储引擎的，既然执行语句的操作是交给存储引擎的，换句话说就是**决定如何处理sql的最终执行权在存储引擎手上**。

##### 2.1.4.1 查询缓冲池

innodb使用缓冲池来缓解磁盘操作的压力，尽量让数据的操作在内存中进行，同时使用不定时脏数据刷盘的操作将内存的数据同步到磁盘，和多数的缓存作用理解一样，在进行查询的时候如果发现命中了缓冲池则会查缓存的数据，否则查磁盘的数据。在查缓存的时候为了防止其他的线程把缓冲池的数据变脏，会对数据进行**加锁**的操作。

##### 2.1.4.2 修改缓冲(change buffer)

**更新一个数据页过程**：

1. 如果数据页在内存 — 直接更新
2. 如果数据页不在内存，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘读入这个数据页了。在下次查询需要访问这个数据页时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式保证这个数据逻辑的正确性。

change buffer, 实际上此操作也是可以持久化的数据。将change buffer中的操作应用到原始数据页，得到最新结果的过程叫merge。除了访问这个数据页会触发merge 外，系统有后台线程会定期merge. 在db正常关闭的时候，也会执行merge。**优点**：如果能够将更新操作先记录在change buffer，减少读磁盘，更新语句的执行速度会得到明显的提升。

**使用场景**：

* Change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做purge之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。

* 对于写多读少的业务，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的是账单类，日志类的系统。

* 反过来，假设一个业务的更新模式就是写入之后马上会做查询，那么即使满足了条件，将先更新记录在change buffer,但之后由于马上要访问这个数据页，会立即出发purge过程。这样随机访问IO的次数不会减少,反而增加了change buffer的维护代价，所以对于这种业务模式来说，change buffer反而起到了副作用。

只有普通索引才能使用到change buffer, 唯一索引不能用。因为唯一索引每次都要将数据页读入内存判断唯一性，所以没必要使用change buffer了。

##### 2.1.4.3 undo日志(引擎层)

**作用**：作用是保存记录的老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。可以用来回滚，崩溃恢复，MVCC。

​	变更操作包括INSERT/DELETE/UPDATE：

* INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除；
* UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo

**产生**: 事务开始之前，将当前的数据版本生成Undo log, Undo log也会产生redo log 来保证Undo log的可靠性。

**释放**：事务提交后，Undo log并不能立马被删除，而是放入待清理的链表，由purge 线程判断是否由其他事务在使用undo 段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。

**存储结构**：InnoDB采用回滚段的方式来维护Undo log的并发写入和持久化。
回滚段实际上是一种Undo 文件组织方式，Undo内部由多个回滚段组成，即 Rollback segment，一共有128个，保存在ibdata系统表空间中，分别从resg slot0 - resg slot127，每一个resg slot，也就是每一个回滚段，内部由1024个undo segment 组成。

为了便于管理和使用undo记录，在内存中维持了如下关键结构体对象：

1. 所有回滚段都记录在 trx_sys->rseg_array，数组大小为128，分别对应不同的回滚段；
2. rseg_array 数组类型为trx_rseg_t，用于维护回滚段相关信息；
3. 每个回滚段对象trx_rseg_t 还要管理undo log信息，对应结构体为trx_undo_t, 使用多个链表来维护trx_undo_t信息；
4. 事务开启时，会专门给他指定一个回滚段，以后该事务用到的undo log页，就从该回滚段上分配；
5. 事务提交后，需要purge的回滚段会被放到purge队列上（purge_sys->purge_queue)。

##### 2.1.4.4 redo日志(引擎层)

**解释**：重做日志，保证事务的持久性；

**总结构**：结构类似缓冲池和硬盘的链接方式，所以从理解上来看需要看作两部分缓冲池和日志文件

**作用**：**记录哪一行的数据进行了修改**并且在**事务提交**将缓存刷新到日志文件进行同步（磁盘io）

为了避免mysql服务操作数据的时候发生了数据丢失的情况，innodb在准备执行事务之前会事先操作一遍redo log buffer的缓冲区，这个缓冲区用来存放哪一行文件的那个字段被修改了，记录数据所在的位置以及改动的数据内容等。

> **事务没有提交，宕机了如何处理**
> **问题**：数据库当中每次执行一条sql都是一个事务的提交。如果数据库崩溃则会出现redo日志丢失的情况，时候mysql如何处理？  
> **解答**：事务都没有提交，说明数据压根没有修改，而且此时虽然缓冲池的数据变了，但是磁盘数据行的内容没有变，所以redo缓冲池的数据丢失了也没有影响，**当宕机重启恢复之后将会通过undo日志把内容进行还原**；

**提交事务之后将redo日志写入磁盘：**

事务提交之后，此时redo会使用一定的策略把redo_log_buffer 的数据刷新到磁盘文件中，可以通过一个配置：**innodb_flush_log_at_trx_commit**更改策略。

* **值为0的时候**：不会把redo_log_buffer的内容刷新到磁盘，此时如果mysql宕机，内存的文件就全部丢失了
* **值为1的时候**：就会在事务提交成功之后把redo缓存数据刷新到日志文件当中，并且文件当中也会存在一条你修改了xxx行那个字段的记录。

> **问题**：此时缓冲池的内容更新了，redo日志的内容也更新了，redo文件里面的内容也记录了记录的修改内容，此时mysql突然宕机了会导致磁盘文件的磁盘数据的不一致么？
> **解答**：肯定不会的，如果此时一旦宕机，缓冲池就会去redo日志恢复之前的修改操作

* **值为2的时候**：提交事务的时候会把redo日志写到os cache里面，而不是写入磁盘，可能会是1秒之后才会把os cache的数据写入到磁盘文件。**但是此时需要注意这个日志文件是在cache里面的，所以意味着一旦宕机os cache的日志内容也没了**。

**三种redo日志刷盘策略总结**: 对于数据特殊要求一般情况下选1就可以了；如果选0，mysql一旦宕机就失效了。如果选2，同样虽然数据是写入到系统缓存的当中。但是还是在内存里面，只要断电宕机，数据同样会丢失。

##### 2.1.4.5 Write-Ahead Logging机制(WAL预写日志)

- 使用日志，存储引擎可以在内存中更新数据，然后将更新持久化到磁盘的日志文件中，不需要每次都将更新后的数据刷新到磁盘（随机IO）
- 日志采用的是追加方式，写日志的操作实在磁盘上一小块区域的顺序IO（比随机IO快得多）
- 日志持久化到磁盘后，内存中被修改的数据（脏页）在后台可以慢慢刷新到磁盘

##### 2.1.4.6 binlog日志(服务层)

**工作流**：其实就是innodb存储引擎在**redo log 准备好数据并且刷新到磁盘之后**，执行器会把数据写入到一个binlog的日志文件进行存储。执行器是非常核心的组件，需要配合存储引擎进行一个sql在磁盘和内存的全部操作。

**刷盘策略**：关键参数：**sync_binlog** 控制刷盘策略。

* **默认值为0**：bin写入磁盘之后，不是直接进入文件，而是和redo_log的参数设置2一样（innodb_flush_log_at_trx_commit = 2）写入到os缓冲池当中，当然会出现宕机的时候丢失缓冲池数据的问题。
* **值1**：会出现在提交事务的时候，强制把缓冲的数据刷新到binlog磁盘里面。

**写入commit标记**

> 问题：redo_log 还需要binlog？
> 解答：整个事务需要在binlog 完成了文件和写入到位置记录之后并且在redolog里面写入commit标记之后才进行处理。所以有了binlog之后，能保证整个事务的最终一致性和完整性。


> 问题：redolog里面写入commit标记有什么意义？
> 解答：本质上是为了保证redolog和binlog一致性

##### 2.1.4.7 两阶段提交2PC

2PC即Innodb对于事务的两阶段提交机制。当MySQL开启binlog的时候，会存在一个内部XA的问题：事务在存储引擎层（redo）commit的顺序和在binlog中提交的顺序不一致的问题。如果不使用两阶段提交，那么数据库的状态有可能用它的日志恢复出来的库的状态不一致。

事务的commit分为prepare和commit两个阶段：

1. **prepare阶段**：redo持久化到磁盘（redo group commit），并将回滚段置为prepared状态，此时binlog不做操作。

<img src="https://github.com/craftlook/Note/blob/master/image/db/mysql-2pc-prepare.png" width="80%" heigth="80%"/>

2. **commit阶段**：innodb释放锁，释放回滚段，设置提交状态，binlog持久化到磁盘，然后存储引擎层提交。

<img src="https://github.com/craftlook/Note/blob/master/image/db/mysql-2pc-commit.png" width="80%" heigth="80%"/>

> 问题：为什么需要二阶段提交？

**解答**：由于存在redo log 和 binlog ，而他们两是相互独立的。而事务提交必须确保两者同时有效。不然会出现不一致的情形。我们对redo log和binlog不进行二阶段提交的顺序进行假设。

1. **先写redolog再写binlog**：redolog写了，binlog还没写，数据库崩了。通过redolog恢复数据库能将这条事务执行，但是binlog没有记录，从数据库就不能执行这条事务（或者在对数据库回到某个点时会没有这条事务），造成不一致的情况。
2. **先写binlog再写redolog**：binlog写了，redolog还没写，数据库崩了。通过redolog恢复数据库没有这条事务，但是binlog记录了，从数据库会执行这条事务（或者在对数据库回到某个点时会有这条事务的执行），造成不一致的情况。

> 问题：二阶段提交怎么解决问题？

<img src="https://github.com/craftlook/Note/blob/master/image/db/mysql-2pc-liu.png" width="40%" heigth="40%"/>


> 上图的①时出现问题怎么解决？

这个时候redo log已经到磁盘了。binlog没有刷到磁盘所以会消失。服务器从故障中恢复时，读取磁盘中的redo log ，但是由于对应的redo log项还是prepare状态，就要判断binlog 是否完整，**如果binlog完整则提交事务，如果binlog不完整则回滚事务**。

> 上图的②时出现问题怎么解决？

这个时候redo log 和 binlog都已经存磁盘，服务器从redo log恢复就好了。

> 怎么判断binlog的完整性?

- statement 模式的 binlog，最后会有 COMMIT；
- row 模式的 binlog，最后会有一个 XID event

注：binlog有三种模式：statement、row和mixed(statement和row的混合)

> 找到redo log后怎么找到binlog？

redo log和binlog有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。

